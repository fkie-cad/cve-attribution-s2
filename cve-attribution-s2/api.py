import io
import logging
import re
import subprocess
import tarfile
from pathlib import Path
from typing import Any, Dict, List, Set, Tuple, Union
from urllib.parse import urljoin

import requests
from packaging import version

logger = logging.getLogger('api')


class Kernel:
    def __init__(self, kconfig: str, kernel_base_dir: Path = Path('kernels'),
                 download_base: str = 'https://cdn.kernel.org/pub/linux/kernel/'):
        self._kconfig = kconfig
        self._base = kernel_base_dir

        self._path_regex = re.compile(
            r'(/?\w+(?:/[^/ ]*)+/\w+\.[cSh])', re.MULTILINE
        )

        self._download_base = download_base

        self.arch, self.version = self._version_find()

        if any([self.arch is None, self.version is None]):
            raise version.InvalidVersion()

        self.version = self._version_format(self.version)

        self.source = self._base / f'linux-{self.version}'

        logger.info('Kernel version \'%s/%s\', Source root \'%s\'', self.version, self.arch,
                    self.source)

    def cache_install(self):
        is_not = 'not ' if not self.source.exists() else ''

        logger.info('Kernel version %s is %sin cache', self.version, is_not)
        if not self.source.exists():
            self.download()

    def download(self):
        logger.info('Downloading kernel version %s...', self.version)
        url = self._download_base + f'v{self.version.major}.x/linux-{self.version}.tar.gz'
        response = requests.get(url)

        logger.info('Extracting kernel version %s to %s...', self.version, self.source)
        with tarfile.open(fileobj=io.BytesIO(response.content), mode='r:gz') as tar:
            tar.extractall(self._base)

    def get_active_files(self) -> Set[Path]:
        if not all([self.clean(), self.kconfig_install()]):
            return set()

        success, build_log = self.dry_build()
        if not success:
            return set()

        files = self._extract_compiled_files(build_log)
        self.clean()

        return files

    def _extract_compiled_files(self, build_log: str) -> Set[Path]:
        logger.info('Extracting all *.[hSc] files from collected build log...')
        unique_matches = set(self._path_regex.findall(build_log))

        result = set()
        for match in unique_matches:
            path = self.source / Path(match)
            if self.source not in path.parents:
                continue
            result.add(path)

        logger.info('Extracted %d unique *.[hSc] files from the build log!', len(result))
        return result

    def kconfig_install(self) -> bool:
        logger.info('Installing kconfig file to cached kernel version %s...', self.version)
        config_path = self.source / '.config'
        config_path.write_text(self._kconfig)

        target_alias = 'oldnoconfig' if self.version < version.parse('4.19') else 'olddefconfig'
        exit_success, _ = self._make(target=target_alias)
        return exit_success

    def clean(self):
        logger.info('Cleaning cached kernel version %s...', self.version)
        exit_success, _ = self._make(target='distclean')
        return exit_success

    def dry_build(self) -> Tuple[bool, str]:
        logger.info('Performing dry-run build of cached kernel version %s...', self.version)
        _, output = self._make(target='all', args='-Bndi')

        try:
            return True, output.decode()
        except UnicodeDecodeError:
            return False, ''

    def _make(self, target: str, args: str = '') -> Tuple[bool, bytes]:
        try:
            logger.info('Executing \'make ARCH=%s %s %s\' in %s...', self.arch, args, target,
                        self.source)
            result = subprocess.check_output(f'make ARCH={self.arch} {args} {target}',
                                             cwd=self.source, stderr=subprocess.DEVNULL,
                                             shell=True)
        except subprocess.CalledProcessError as err:
            return False, err.output
        return True, result

    def _version_find(self) -> Union[Tuple[str, version.Version], Tuple[None, None]]:
        expression = re.compile(
            r'^# Linux/(.+)\s((\d+\.?){1,4}) Kernel Configuration$', re.MULTILINE
        )
        matches = expression.findall(self._kconfig)
        if matches is not None and len(matches) > 0:
            arch = matches[0][0]
            ver = version.parse(matches[0][1])
            return arch, self._version_format(ver)
        return None, None

    @staticmethod
    def _version_format(ver: version.Version) -> version.Version:
        if isinstance(ver, str):
            ver = version.parse(ver)
        version_fmt = f'{ver.major}.{ver.minor}'
        if ver.micro != 0:
            version_fmt += f'.{ver.micro}'
        return version.parse(version_fmt)


class FACT:
    def __init__(self, base_url: str = 'http://127.0.0.1:5000'):
        self._base = base_url
        self._endpoint = {
            'file_object': urljoin(self._base, 'rest/file_object'),
        }

    def get_ikconfig_matches(self) -> List[str]:
        logger.info('Fetching ikconfig matches from FACT')
        resp = requests.get(
            url=self._endpoint['file_object'],
            params='query={"processed_analysis.kernel_config.summary": "Kernel Config"}'
        )
        return resp.json()['uids']

    def fetch_file_object(self, oid: str) -> Dict[str, Any]:
        logger.info('Fetching file object from FACT: %s', oid)
        resp = requests.get(url=self._endpoint['file_object'] + '/' + oid)
        return resp.json()['file_object']

    def get_kernel_configs(self) -> Dict[str, Set[str]]:
        file_object_ids = self.get_ikconfig_matches()
        kernel_configs = dict()

        for identifier in file_object_ids:
            file_object = self.fetch_file_object(identifier)
            try:
                kconfig = file_object['analysis']['kernel_config']['kernel_config']
                firmware_ids = file_object['meta_data']['firmwares_including_this_file']
                kernel_configs = self._update_configs_dict(kernel_configs, kconfig, firmware_ids)
            except KeyError:
                continue

        return kernel_configs

    @staticmethod
    def _update_configs_dict(configs: Dict[str, Set[str]], kconfig: str,
                             firmware_ids: str) -> Dict[str, Set[str]]:
        for firmware in firmware_ids:
            if firmware not in configs:
                configs[firmware] = set()
            configs[firmware].add(kconfig)
        return configs
