import argparse
import json
import logging
import sys
from pathlib import Path
from typing import Any, Dict, Union
from urllib.parse import urlparse

import requests.exceptions
from packaging import version

import api
import db
import match

logger = logging.getLogger('main')


def setup(args):
    logging.basicConfig(level=logging.INFO)
    db.connect(host=args.cve)


def url_type(arg: str) -> str:
    result = urlparse(arg)
    if not all([result.scheme, result.netloc]):
        raise ValueError
    return result.geturl()


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description='Improved CVE Matching to Kernel/Architecture/KConfig-Combinations')
    parser.add_argument('--fact', type=url_type, help='FACT endpoint base url',
                        default='http://127.0.0.1:5000/')
    parser.add_argument('--cve', type=url_type, help='CVE-DB connection url',
                        default='mongodb://root:cve@127.0.0.1:28000/nvd?authSource=admin')
    parser.add_argument('--output_applicable', type=Path, help='json output applicable file', default=Path('output_applicable.json'))
    parser.add_argument('--output_relative_applicable', type=Path, help='json output relative applicable file', default=Path('output_relative_applicable.json'))
    parser.add_argument('--output_not_applicable', type=Path, help='json output not applicable file', default=Path('output_not_applicable.json'))
    parser.add_argument('--output_unknown', type=Path, help='json output unknown applicability file', default=Path('output_unknown_applicable.json'))
    parser.add_argument('--output_version', type=Path, help='json output naive version based applicable file', default=Path('output_version_applicable.json'))

    return parser.parse_args()


def get_kernel_configs(fact: api.FACT) -> Union[Dict[str, Any], None]:
    try:
        return fact.get_kernel_configs()
    except requests.exceptions.ConnectionError as e:
        logging.debug(e)
        logger.error('Could not get kernel configs from FACT')
        return None


def save_results(results: Dict[str, Any], path: Path):
    try:
        path.write_text(json.dumps(results, indent=4))
        return True
    except (OSError, TypeError) as e:
        logging.debug(e)
        logger.error('Could not write results to output file %s', str(path))
        return False


def main() -> int:
    args = parse_args()

    setup(args)

    fact = api.FACT(base_url=args.fact)
    kernel_configs = get_kernel_configs(fact)
    if kernel_configs is None:
        return 1

    results_applicable = {}
    results_relative_applicable = {}
    results_not_applicable = {}
    results_unknown = {}
    results_version_applicable = {}

    for firmware, configs in kernel_configs.items():
        logger.info('Firmware %s', firmware)
        for kconfig in configs:
            try:
                kernel = api.Kernel(kconfig=kconfig)
            except version.InvalidVersion:
                continue
            kernel.cache_install()
            source_files = kernel.get_active_files()

            config_matcher = match.KernelCVEMatcher(kernel)
            results_applicable.setdefault(firmware, {})
            results_relative_applicable.setdefault(firmware, {})
            results_not_applicable.setdefault(firmware, {})
            results_version_applicable.setdefault(firmware, {})
            results_unknown.setdefault(firmware, {})
            applicable, relative_applicable, not_applicable, unknown, version_applicable = config_matcher.match_cves(source_files)
            results_applicable[firmware][str(config_matcher.kernel.version)] = applicable
            results_relative_applicable[firmware][str(config_matcher.kernel.version)] = relative_applicable
            results_not_applicable[firmware][str(config_matcher.kernel.version)] = not_applicable
            results_unknown[firmware][str(config_matcher.kernel.version)] = unknown
            results_version_applicable[firmware][str(config_matcher.kernel.version)] = version_applicable

    if not save_results(results_applicable, args.output_applicable):
        return 1
    if not save_results(results_relative_applicable, args.output_relative_applicable):
        return 1
    if not save_results(results_not_applicable, args.output_not_applicable):
        return 1
    if not save_results(results_unknown, args.output_unknown):
        return 1
    if not save_results(results_version_applicable, args.output_version):
        return 1
    return 0


if __name__ == '__main__':
    sys.exit(main())
