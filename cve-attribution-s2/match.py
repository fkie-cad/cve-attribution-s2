import logging
import operator as op
import re
from pathlib import Path
from typing import List, Set, Dict

from packaging import version

import api
import db
from db.models.cve import CPEMatch, CVEItem

logger = logging.getLogger('match')


class KernelCVEMatcher:

    def __init__(self, kernel: api.Kernel):
        self.kernel = kernel
        self._path_regex = re.compile(
            r'([^\s]*\w+\.[cSh])'
        )

    @staticmethod
    def cves_from_db() -> List[CVEItem]:
        elem_match = {
            '$elemMatch': {
                'cpe23Uri': {'$regex': ':linux:linux_kernel:'},
                'vulnerable': True
            }
        }
        search_locations = [
            'configurations.nodes.children.cpe_match',
            'configurations.nodes.cpe_match',
            'configurations.cpe_match'
        ]

        result = db.models.CVEItem.objects(__raw__={
            '$or': [{x: elem_match} for x in search_locations]
        })

        return result

    def filter_by_kernel_version(self, cve_list: List[CVEItem]):
        logger.info('Filtering list of CVEs by matching the linux kernel version')
        filtered = list()
        for cve in cve_list:
            for cpe in self.aggregate_cpes(cve):
                if self.cpe_is_linux_kernel(cpe) and self.cpe_affects_this_version(cpe):
                    filtered.append(cve)
                    logger.debug('%s affects linux kernel version %s', cve.cve.CVE_data_meta.ID,
                                 self.kernel.version)
                    break
        return filtered

    def filter_by_source_file_hint(self, cve_list: List[CVEItem],
                                   source_files: Set[Path]) -> List[CVEItem]:
        logger.info('Filtering list of CVEs by matching source files mentioned in the description'
                    ' using our local build log')
        applicable = list()
        relative_applicable = list()
        unknown = list()
        not_applicable = list()
        for cve in cve_list:
            cve_description = cve.cve.description.description_data.first().value
            file_path_list = self._path_regex.findall(cve_description)
            if len(file_path_list) == 0:
                unknown.append(cve)
                continue

            found = False
            for file_path in file_path_list:
                file_key = self.kernel.source / file_path
                if file_key in source_files:
                    logger.debug('%s affects the present kconfig because %s is being compiled into'
                                 'the kernel or a module', cve.cve.CVE_data_meta.ID, file_key)
                    applicable.append(cve)
                    found = True
                    break
                if '/' not in str(file_path): # issuer was lazy and didn't specify subfolder of affected file
                    if any(Path(file_path).name in str(src) for src in source_files):
                        relative_applicable.append(cve)
                        found = True
                        break

            if not found:
                not_applicable.append(cve)

        return applicable, relative_applicable, not_applicable, unknown

    def match_cves(self, source_files: Set[Path]) -> List[Dict]:
        cve_list = self.cves_from_db()
        kernel_version_matches = self.filter_by_kernel_version(cve_list)
        applicable, relative_applicable, not_applicable, unknown = self.filter_by_source_file_hint(kernel_version_matches, source_files)
        logger.info('Found %d CVEs that affect the present setup of both linux kernel and kconfig',
                    len(applicable))
        logger.info('Found %d CVEs that MAY affect the present setup of both linux kernel and kconfig (file name but no absolute path in source tree)',
                    len(relative_applicable))
        logger.info('Found %d CVEs that definitely do not affect the present setup of both linux kernel and kconfig',
                    len(not_applicable))
        logger.info('Found %d CVEs that are of unknown applicability because no file name is inside the cve description',
                    len(unknown))

        return [self._to_list_of_dicts(cve_list) for cve_list in [applicable, relative_applicable, not_applicable, unknown, kernel_version_matches]] 

    @staticmethod
    def _to_list_of_dicts(cve_list: List[CVEItem]) -> List[Dict]:
        result = list()
        for cve in cve_list:
            cve_dict = cve.to_mongo().to_dict()
            # mongo id is not required outside of dbms, save some bytes.
            del cve_dict['_id']
            result.append(cve_dict)
        return result

    def cpe_affects_this_version(self, cpe: CPEMatch) -> bool:
        center = self.kernel.version

        left = None
        right = None

        if cpe.versionStartExcluding is not None:
            left = dict(op=op.lt, ver=version.parse(cpe.versionStartExcluding))
        elif cpe.versionStartIncluding is not None:
            left = dict(op=op.le, ver=version.parse(cpe.versionStartIncluding))

        if cpe.versionEndExcluding is not None:
            right = dict(op=op.lt, ver=version.parse(cpe.versionEndExcluding))
        elif cpe.versionEndIncluding is not None:
            right = dict(op=op.le, ver=version.parse(cpe.versionEndIncluding))

        if all([left is None, right is None]):
            return False

        smaller_than_right = right['op'](center, right['ver']) if right is not None else True
        larger_than_left = left['op'](left['ver'], center) if left is not None else True

        return larger_than_left and smaller_than_right

    @staticmethod
    def cpe_is_linux_kernel(cpe: CPEMatch) -> bool:
        return ':linux:linux_kernel:' in cpe.cpe23Uri and cpe.vulnerable

    @staticmethod
    def aggregate_cpes(cve: CVEItem) -> List[CPEMatch]:
        # multiple CPE locations in CVE data set
        matches = list(cve.configurations.cpe_match)
        for node in cve.configurations.nodes:
            matches += node.cpe_match
            for child in node.children:
                matches += child.cpe_match

        # when there is no match, cpe_match is None, we need to filter that
        return list(filter(lambda cpe: isinstance(cpe, CPEMatch), matches))
